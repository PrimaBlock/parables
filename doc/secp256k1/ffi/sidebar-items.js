initSidebarItems({"constant":[["SECP256K1_SER_COMPRESSED","Flag for keys to indicate compressed serialization format"],["SECP256K1_SER_UNCOMPRESSED","Flag for keys to indicate uncompressed serialization format"],["SECP256K1_START_NONE","Flag for context to enable no precomputation"],["SECP256K1_START_SIGN","Flag for context to enable signing precomputation"],["SECP256K1_START_VERIFY","Flag for context to enable verification precomputation"]],"fn":[["ecdsa_signature_parse_der_lax",""],["secp256k1_context_clone",""],["secp256k1_context_create",""],["secp256k1_context_destroy",""],["secp256k1_context_randomize",""],["secp256k1_ec_privkey_inverse",""],["secp256k1_ec_privkey_tweak_add",""],["secp256k1_ec_privkey_tweak_mul",""],["secp256k1_ec_pubkey_combine",""],["secp256k1_ec_pubkey_create",""],["secp256k1_ec_pubkey_parse",""],["secp256k1_ec_pubkey_serialize",""],["secp256k1_ec_pubkey_tweak_add",""],["secp256k1_ec_pubkey_tweak_mul",""],["secp256k1_ec_seckey_verify",""],["secp256k1_ecdh",""],["secp256k1_ecdh_raw",""],["secp256k1_ecdsa_recover",""],["secp256k1_ecdsa_recoverable_signature_convert",""],["secp256k1_ecdsa_recoverable_signature_parse_compact",""],["secp256k1_ecdsa_recoverable_signature_serialize_compact",""],["secp256k1_ecdsa_sign",""],["secp256k1_ecdsa_sign_recoverable",""],["secp256k1_ecdsa_signature_normalize",""],["secp256k1_ecdsa_signature_parse_der",""],["secp256k1_ecdsa_signature_serialize_der",""],["secp256k1_ecdsa_verify",""],["secp256k1_schnorr_recover",""],["secp256k1_schnorr_sign",""],["secp256k1_schnorr_verify",""]],"static":[["secp256k1_nonce_function_default",""],["secp256k1_nonce_function_rfc6979",""]],"struct":[["Context","A Secp256k1 context, containing various precomputed values and such needed to do elliptic curve computations. If you create one of these with `secp256k1_context_create` you MUST destroy it with `secp256k1_context_destroy`, or else you will have a memory leak."],["PublicKey","Library-internal representation of a Secp256k1 public key"],["RecoverableSignature","Library-internal representation of a Secp256k1 signature + recovery ID"],["SharedSecret","Library-internal representation of an ECDH shared secret"],["Signature","Library-internal representation of a Secp256k1 signature"]],"type":[["NonceFn","A nonce generation function. Ordinary users of the library never need to see this type; only if you need to control nonce generation do you need to use it. I have deliberately made this hard to do: you have to write your own wrapper around the FFI functions to use it. And it's an unsafe type. Nonces are generated deterministically by RFC6979 by default; there should be no need to ever change this."]]});