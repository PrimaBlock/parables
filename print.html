<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parables User Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="01_intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="02_getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><a href="03_testing_smart_contracts.html"><strong aria-hidden="true">3.</strong> Testing Smart Contracts</a></li><li><a href="04_property_testing.html"><strong aria-hidden="true">4.</strong> Property Testing</a></li><li><a href="05_testing_for_reverts.html"><strong aria-hidden="true">5.</strong> Testing for Reverts</a></li><li><a href="06_account_balances.html"><strong aria-hidden="true">6.</strong> Account Balances</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Parables User Guide</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#introduction-to-parables" id="introduction-to-parables"><h1>Introduction to Parables</h1></a>
<p>Parables is a system for testing smart contracts.
Smart contracts are <em>hard</em> to get right and the cost of making mistakes is high.
The way we avoid mistakes is by being exceptional at testing.</p>
<p>Parables was built at <a href="https://github.com/primablock">PrimaBlock</a> to support thorough testing of contracts.
We wanted to make use of <a href="https://en.wikipedia.org/wiki/Property_testing">property testing</a>,
but found that conventional testing frameworks like <a href="https://truffleframework.com/">Truffle</a> were
too slow to support that.</p>
<p>Property testing typically requires that the thing under test is executed hundreds of times with
different valued, randomized parameters.
For this reason, individual test cases must be <em>fast</em>.
Parables is able to execute complex contract interactions in microseconds since we do it directly
on top of the <a href="https://github.com/paritytech/parity">parity virtual machine</a>. We also intend to make testing a first-class citizen of
parity by extending the necessary primitives to get it done the right way.</p>
<a class="header" href="print.html#about-this-book" id="about-this-book"><h2>About this book</h2></a>
<p>This book is a user guide, suitable for people who want to learn how to do testing on top of
parables.</p>
<p>It requires an understanding of Rust, and that you have the <code>cargo</code> toolchain installed.
If you don't have it, you can get it through <a href="https://rustup.rs">rustup.rs</a>.</p>
<p>We will guide you all the way from <a href="./02_getting_started.html">setting up a new project</a>, to performing full-scale
<a href="./04_property_testing.html">property testing</a>.</p>
<p>So sit down, buckle your seat belt, and enjoy the trip!</p>
<a class="header" href="print.html#reference-documentation" id="reference-documentation"><h2>Reference Documentation</h2></a>
<p>You can find generated documentation for the parables framework at
<a href="./doc/parables_testing/">./doc/parables_testing/</a>, in particular you should check out the
<a href="./doc/parables_testing/prelude/index.html"><code>prelude</code></a> which links to everything that is imported by default.</p>
<a class="header" href="print.html#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<p>Parables runs as a regular application using a custom testing framework.
To run this you should set up a regular rust application. This can easiest be done using <code>cargo init</code>.</p>
<pre><code class="language-bash">cargo init --bin my-contract-tests
</code></pre>
<p>Modify the <code>Cargo.toml</code> to add a dependency to parables:</p>
<pre><code class="language-toml">[dependencies]
parables-testing = {git = &quot;https://github.com/primablock/parables&quot;}

[build-dependencies]
parables-build = {git = &quot;https://github.com/primablock/parables&quot;}
</code></pre>
<p>If you want parables to try to build your contracts automatically, add the following <code>build.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate parables_build;

fn main() {
    if let Err(e) = parables_build::compile(concat!(env!(&quot;CARGO_MANIFEST_DIR&quot;), &quot;/contracts&quot;)) {
        panic!(&quot;failed to compile contracts: {:?}&quot;, e);
    }
}
</code></pre></pre>
<p>Finally you should set up a main method that uses <code>TestRunner</code> to schedule tests in <code>src/main.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate parables_testing;

use parables_testing::prelude::*;

fn main() -&gt; Result&lt;()&gt; {
    let mut tests = TestRunner::new();

    tests.test(&quot;something cool&quot;, || {
        assert_eq!(1, 2);
    });

    let reporter = StdoutReporter::new();
    tests.run(&amp;reporter)?;

    Ok(())
}
</code></pre></pre>
<p>At this stage you can test that everything works with <code>cargo run</code>.</p>
<pre><code class="language-bash">cargo run
</code></pre>
<pre><code>something cool in 0s: failed at src/main.rs:9:9
assertion failed: `(left == right)`
  left: `1`,
 right: `2`
</code></pre>
<p>Now it's time to add a smart contract.</p>
<p>Create the contracts directory, and write the <code>SimpleContract</code> code below into
<code>contracts/SimpleContract.sol</code>.</p>
<pre><code class="language-bash">mkdir contracts
</code></pre>
<pre><code class="language-solidity">/// contracts/SimpleContract.sol

pragma solidity 0.4.24;

contract SimpleContract {
    uint value;
    address owner;

    event ValueUpdated(uint);

    constructor(uint initial) public {
        value = initial;
        owner = msg.sender;
    }

    modifier ownerOnly() {
        require(msg.sender == owner);
        _;
    }

    function getValue() public view returns(uint) {
        return value;
    }

    function setValue(uint update) public ownerOnly() {
        value = update;
        emit ValueUpdated(update);
    }
}
</code></pre>
<p>Compile the contract using <code>solcjs</code>.</p>
<pre><code class="language-bash">(cd contracts &amp;&amp; solcjs *.sol --bin --abi)
</code></pre>
<p>We then load it by adding the <code>contracts!</code> macro to the top of our file.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate parables_testing;

use parables_testing::prelude::*;

contracts! {
    simple_contract {
        &quot;contracts/SimpleContract_sol_SimpleContract.abi&quot;,
        &quot;contracts/SimpleContract_sol_SimpleContract.bin&quot;
    },
}

fn main() -&gt; Result&lt;()&gt; {
    let mut tests = TestRunner::new();

    tests.test(&quot;something cool&quot;, || {
        assert_eq!(1, 2);
    });

    let reporter = StdoutReporter::new();
    tests.run(&amp;reporter)?;

    Ok(())
}
</code></pre></pre>
<p>In the next section we will walk you through how to write your first contract test.</p>
<a class="header" href="print.html#testing-smart-contracts" id="testing-smart-contracts"><h1>Testing Smart Contracts</h1></a>
<p>To test a smart contract, we run it on top of the Ethereum Virtual Machine (EVM) built by <a href="https://github.com/paritytech/parity">parity</a>.</p>
<p>Parables provides a wrapper for this using the <code>Evm</code> type.</p>
<p>But before we start testing our contracts, we need to make sure that they are <em>compiled</em> into
bytecode and abi.</p>
<p>To do this, we can use solcjs.</p>
<pre><code class="language-bash">(cd contracts &amp;&amp; solcjs *.sol --bin --abi)
</code></pre>
<p>After this, you can put the following in <code>src/main.rs</code>.
Don't worry, we will walk you through line-by-line what it is below.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate parables_testing;

use parables_testing::prelude::*;

contracts! {
    simple_contract {
        &quot;contracts/SimpleContract_sol_SimpleContract.abi&quot;,
        &quot;contracts/SimpleContract_sol_SimpleContract.bin&quot;
    },
}

fn main() -&gt; Result&lt;()&gt; {
    // Set up a template call with a default amount of gas.
    let owner = Address::random();
    let call = Call::new(owner).gas(1_000_000);

    // Initialize a new linker.
    let mut linker = Linker::new();

    // Set up a new virtual machine with a default (null) foundation.
    let foundation = Spec::new_null();
    let mut evm = Evm::new(&amp;foundation)?;

    // Deploy the SimpleContract.
    let code = simple_contract::bin(&amp;linker)?;
    let simple = evm.deploy(simple_contract::constructor(code, 0), call)?.address;

    // Wrap the virtual machine in a Snapshot type so that it can be shared as a snapshot across
    // threads.
    let evm = Snapshot::new(evm);

    let mut tests = TestRunner::new();

    tests.test(&quot;get and increment value a couple of times&quot;, || {
        use simple_contract::events as ev;
        use simple_contract::functions as f;

        let mut evm = evm.get()?;

        let mut expected = U256::from(0);

        let out = evm.call(simple, f::get_value(), call)?.output;
        assert_eq!(expected, out);

        // change value
        expected = 1.into();

        evm.call(simple, f::set_value(expected), call)?;
        let out = evm.call(simple, f::get_value(), call)?.output;
        assert_eq!(expected, out);

        Ok(())
    });

    let reporter = StdoutReporter::new();
    tests.run(&amp;reporter)?;

    Ok(())
}
</code></pre></pre>
<p>We will now walk through this line-by-line and explain what it is.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use parables_testing::prelude::*;
#}</code></pre></pre>
<p>This imports everything necessary to write parables test into the current scope.</p>
<p>Check out the <a href="./doc/parables_testing/prelude/index.html">prelude documentation</a> as a reference for what is imported.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
contracts! {
    simple_contract {
        &quot;contracts/SimpleContract_sol_SimpleContract.abi&quot;,
        &quot;contracts/SimpleContract_sol_SimpleContract.bin&quot;
    },
}
#}</code></pre></pre>
<p>This makes use of ethabi's derive module to build a type-safe model for the contract that we can
use through the <code>simple_contract</code> module.</p>
<p>Through this we can import <code>functions</code>, <code>events</code>, and the contract's <code>constructor</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let owner = Address::random();
let call = Call::new(owner).gas(1_000_000);
#}</code></pre></pre>
<p>In main, we start by creating a random <code>owner</code>, and set up the template model we will be using for
our calls.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut linker = Linker::new();
#}</code></pre></pre>
<p>Next we set up our linker. There is currently no configuration necessary since our contract doesn't
link to any other contracts. But we need one anyways.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foundation = Spec::new_null();
let mut evm = Evm::new(&amp;foundation)?;
#}</code></pre></pre>
<p>Time to set up our <em>foundation</em>. A foundation determines the parameters of the blockchain.
The <code>null</code> foundation is the default foundation, which makes it operate like your modern Ethereum
blockchain.
But we also have access to older foundations like [<code>morden</code>].</p>
<p>The currently available foundations are:</p>
<ul>
<li><code>Spec::new_null</code> - The most default foundation which doesn't have a consensus engine.</li>
<li><code>Spec::new_instant</code> - A default foundation which has an InstantSeal consensus engine.</li>
<li><code>Spec::new_test</code> - Morden without a consensus engine.</li>
</ul>
<p>For more details, you'll currently have to reference the <a href="https://github.com/paritytech/parity/blob/master/ethcore/src/spec/spec.rs">Spec source code</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let code = simple_lib::bin(&amp;linker)?;
let simple = evm.deploy(simple_contract::constructor(code, 0), call)?.address;
#}</code></pre></pre>
<p>For the next line we link our contract, and deploy it to our virtual machine by calling its
constructor.</p>
<p>Note that the first argument of the constructor is the code to deploy.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let evm = Snapshot::new(evm);
#}</code></pre></pre>
<p>Finally we want to wrap our virtual machine in the <code>Snapshot</code> container.
The virtual machine has some state that needs to be synchronized when shared across threads, but it
is clonable.
The Snapshot class provides us with a convenient <code>get()</code> function that handles the cloning for us.</p>
<p>Next we enter the code for the test case.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use simple_contract::events as ev;
use simple_contract::functions as f;
#}</code></pre></pre>
<p>We start out by importing all relevant functions into scope for the test.</p>
<p>Using these we can access all events being emitted by the contract through <code>ev::SomeEvent</code>, and all
the functions being exposed as <code>f::some_function</code>.
Note that the function names are converted from lower camel (solidity standard) to lower snake case
(rust standard).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut evm = evm.get()?;
#}</code></pre></pre>
<p>This line takes a snapshot of the virtual machine.
The snapshot is guaranteed to be isolated from all other snapshots, letting us run many tests in
isolation without worrying about trampling on each others feets.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut expected = 0;

let out = evm.call(simple, f::get_value(), call)?.output;
assert_eq!(expected, out);

// change value
expected = 1;

evm.call(simple, f::set_value(expected), call)?;
let out = evm.call(simple, f::get_value(), call)?.output;
assert_eq!(expected, out);
#}</code></pre></pre>
<p>This final snippet is the complete test case.
We call the <code>getValue()</code> solidity function and compare its <code>output</code>, set it using <code>setValue(uint)</code>,
and make sure that it has been set as expected by getting it again.</p>
<p>So it's finally time to run your test!
You do this by calling <code>cargo run</code>.</p>
<pre><code class="language-bash">cargo run
</code></pre>
<a class="header" href="print.html#property-testing" id="property-testing"><h1>Property Testing</h1></a>
<p>Parables provides the necessary <em>speed</em> to perform property testing of smart contracts.</p>
<p>We make use of the excellent <a href="https://github.com/AltSysrq/proptest"><code>proptest</code></a> framework to accomplish this.</p>
<p>Let's rewrite our example from the last chapter to instead of testing that we can get and set some
well-defined numeric values, we test a wide range of values.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
tests.test(&quot;get and increment value randomly&quot;, pt!{
    |(x in any::&lt;u64&gt;())| {
        use simple_contract::functions as f;

        let x = U256::from(x);

        let mut evm = evm.get()?;

        let out = evm.call(simple, f::get_value(), call)?.output;
        assert_eq!(U256::from(0), out);

        evm.call(simple, f::set_value(x), call)?;
        let out = evm.call(simple, f::get_value(), call)?.output;
        assert_eq!(x, out);
    }
});
#}</code></pre></pre>
<p>For the heck of it, let's introduce a require that will prevent us from setting the field to
a value larger or equal to <code>1000000</code>.</p>
<pre><code class="language-solidity">function setValue(uint update) public ownerOnly() {
    require(value &lt; 1000000);
    value = update;
    emit ValueUpdated(value);
}
</code></pre>
<p>What does our test case say?</p>
<pre><code class="language-bash">cargo run
</code></pre>
<pre><code>get and increment value randomly in 0.144s: failed at src/main.rs:36:9
Test failed: call was reverted; minimal failing input: x = 1000000
        successes: 0
        local rejects: 0
        global rejects: 0
</code></pre>
<p>What's happening here is actually quite remarkable.
When proptest notices a failing, random, input, it tries to <em>reduce</em> the value to minimal failing
test.
The exact strategy is determined by the type being mutated, but for numeric values it performs
a binary search through all the inputs.</p>
<p>For more information on property testing, please read the <a href="https://github.com/AltSysrq/proptest">proptest README</a>.</p>
<p>In the next section we will discuss how to <em>expect</em> that a transaction is reverted.</p>
<a class="header" href="print.html#testing-for-reverts" id="testing-for-reverts"><h1>Testing for Reverts</h1></a>
<p>Now we will use the contract from the last section, but instead of simply failing, we will change
the assert to expect the revert to happen for some specific input.</p>
<p>Given that <code>getValue</code> looks like this (from the last section).</p>
<pre><code class="language-solidity">function setValue(uint update) public ownerOnly() {
    require(value &lt; 1000000);
    value = update;
}
</code></pre>
<p>We do that by changing the test case to this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
tests.test(&quot;get and increment value randomly within constraints&quot;, pt!{
    |(x in any::&lt;u64&gt;())| {
        use simple_contract::functions as f;

        let x = U256::from(x);

        let mut evm = evm.get()?;

        let out = evm.call(simple, f::get_value(), call)?.output;
        assert_eq!(U256::from(0), out);

        let result = evm.call(simple, f::set_value(x), call);

        // expect that the transaction is reverted if we try to update the value to a value larger
        // or equal to 1 million.
        let expected = if x &gt;= U256::from(1000000) {
            assert!(result.is_reverted());
            U256::from(0)
        } else {
            assert!(result.is_ok());
            x
        };

        let out = evm.call(simple, f::get_value(), call)?.output;
        assert_eq!(expected, out);
    }
});
#}</code></pre></pre>
<p>Instead of an error, our test should now pass.</p>
<pre><code>cargo run
</code></pre>
<pre><code>get and increment value randomly within constraints in 0.686s: ok
</code></pre>
<a class="header" href="print.html#account-balances" id="account-balances"><h1>Account Balances</h1></a>
<p>Every address has an implicit <em>account</em> associated with it.
The account acts like a ledger, keeping track of of the balance in ether that any given address
has.</p>
<p>Accounts are always in use, any transaction takes into account the amount of ether being attached
to it and any gas being used.</p>
<p>To make use of balances, we first need to provide an address with a balance.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foundation = Spec::new_null();
let mut evm = Evm::new(&amp;foundation);

let a = Address::random();
let b = Address::random();

evm.add_balance(a, wei::from_ether(100));
#}</code></pre></pre>
<p>The first way we can change the balance of an account is to transfer ether from one account to
another using a default call.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let call = Call::new(a).gas(21000).gas_price(10);
let res = evm.call_default(b, call)?;
#}</code></pre></pre>
<p>We can now check the balance for each account to make sure it's been modified.</p>
<p>Note that account <code>a</code> doesn't have <code>90</code> ether, we have to take the gas subtracted into account!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
assert_ne!(evm.balance(a), wei::from_ether(90));
assert_eq!(evm.balance(a), wei::from_ether(90) - res.gas_total());
assert_eq!(evm.balance(b), wei::from_ether(10));
#}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
